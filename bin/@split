#!/usr/bin/env node
const clefairy = require("clefairy");
const kleur = require("kleur");
const readStdin = require("../lib/read-stdin");
const printHelp = require("../lib/print-help");

clefairy.run(
  {
    help: clefairy.optionalBoolean,
    h: clefairy.optionalBoolean,
    n: clefairy.optionalBoolean,
  },
  async (options, ...args) => {
    if (options.help || options.h) {
      printHelp(
        "split stdin on a delimiter, and print the resulting strings as a JSON array",
        `
          Reads stdin as a string, then calls its .split method, passing in the
          delimiter string/regexp you pass as the first argument to @BINARY_NAME@,
          or /[\\s]+/g if unspecified.

          The return value of .split is then passed through JSON.stringify
          and printed to stdout.

          If -n is passed, then if the last element of the Array returned from .split is empty,
          it will be omitted.
        `,
        `
          echo "hello world" | @BINARY_NAME@
          ls . | @BINARY_NAME@ "\\n"
          cat ./myTextFile.txt | @BINARY_NAME@ "\\n" -n
        `
      );
    }
    let delimiter = /[\s]+/g;

    let delimString = args[0];

    // There's a bug in clef-parse where empty positional argument strings aren't in args.
    // This is a workaround, but I'll fix it properly in clef-parse later.
    // This only matters if they passed "" as a positional argument.
    if (args.length === 0 && process.argv.some((arg) => arg === "")) {
      delimiter = "";
    } else if (delimString != null) {
      try {
        delimiter = JSON.parse(delimString); // quoted string
      } catch (err) {
        try {
          if (/^\//.test(delimString) && /\/\w*$/.test(delimString)) {
            delimiter = new Function("return " + delimString)();
          } else {
            delimiter = new Function("return " + "/" + delimString + "/g")();
          }
          console.error(
            kleur.dim(
              `parsed ${JSON.stringify(
                delimString
              )} into ${delimiter}. If you don't want this, wrap your delimiter string arg in double quotes, eg '"${delimString}"'`
            )
          );
        } catch (err) {
          throw new Error(
            "Failed to parse delimiter as regexp: " + err.message
          );
        }
      }
    }

    const stdinStr = await readStdin("string");

    let items = stdinStr.split(delimiter);

    if (options.n && items[items.length - 1] === "") {
      items.pop();
    }

    console.log(JSON.stringify(items, null, 2));
  }
);
